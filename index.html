<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
	<meta name="viewport" content="width=530, user-scalable=no">
    <title>ToneMatrix Redux, a no-Flash pentatonic step sequencer</title>
	<link rel="apple-touch-icon" sizes="57x57" href="icons/apple-icon-57x57.png">
	<link rel="apple-touch-icon" sizes="60x60" href="icons/apple-icon-60x60.png">
	<link rel="apple-touch-icon" sizes="72x72" href="icons/apple-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="76x76" href="icons/apple-icon-76x76.png">
	<link rel="apple-touch-icon" sizes="114x114" href="icons/apple-icon-114x114.png">
	<link rel="apple-touch-icon" sizes="120x120" href="icons/apple-icon-120x120.png">
	<link rel="apple-touch-icon" sizes="144x144" href="icons/apple-icon-144x144.png">
	<link rel="apple-touch-icon" sizes="152x152" href="icons/apple-icon-152x152.png">
	<link rel="apple-touch-icon" sizes="180x180" href="icons/apple-icon-180x180.png">
	<link rel="icon" type="image/png" sizes="192x192"  href="icons/android-icon-192x192.png">
	<link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="96x96" href="icons/favicon-96x96.png">
	<link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
	<link rel="manifest" href="icons/manifest.json">
	<meta name="msapplication-TileColor" content="#ffffff">
	<meta name="msapplication-TileImage" content="icons/ms-icon-144x144.png">
	<meta name="theme-color" content="#ffffff">
	<style>
		@font-face {
			font-family: 'Montserrat';
			src: url('montserrat-thin-webfont.woff2') format('woff2');
			font-weight: 100;
			font-style: normal;

		}
		html, body {
			background: black;
			margin: 0;
			width: 100%;
			height: 100%;
			font-family: Arial, sans-serif;
		}
		body {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
		}
		body, a {
			color: #777;
		}
		h1 {
			font-family: 'Montserrat', sans-serif;
			font-weight: 100;
			color: #ddd;
		}
	</style>
  </head>
  <body>
	<h1>ToneMatrix Redux</h1>
    <canvas width="500" height="500"></canvas>
	<p>By <a href="https://www.maxlaumeister.com/">Max L</a> - Based on <a href="https://tonematrix.audiotool.com/">ToneMatrix</a> - <a href="https://github.com/MaxLaumeister/ToneMatrixRedux">View on GitHub</a>
	<script src="Tone.js"></script>
	<script>
		(function() {
			// Color mixer
			// https://stackoverflow.com/a/32171077/2234742
			
			//colorChannelA and colorChannelB are ints ranging from 0 to 255
			function colorChannelMixer(colorChannelA, colorChannelB, amountToMix){
				var channelA = colorChannelA*amountToMix;
				var channelB = colorChannelB*(1-amountToMix);
				return parseInt(channelA+channelB);
			}
			//rgbA and rgbB are arrays, amountToMix ranges from 0.0 to 1.0
			//example (red): rgbA = [255,0,0]
			function colorMixer(rgbA, rgbB, amountToMix){
				var r = colorChannelMixer(rgbA[0],rgbB[0],amountToMix);
				var g = colorChannelMixer(rgbA[1],rgbB[1],amountToMix);
				var b = colorChannelMixer(rgbA[2],rgbB[2],amountToMix);
				return "rgb("+r+","+g+","+b+")";
			}
			
			// Draw Rounded Rectangle
			// https://stackoverflow.com/a/3368118/2234742
			function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
			  if (typeof stroke === 'undefined') {
				stroke = true;
			  }
			  if (typeof radius === 'undefined') {
				radius = 5;
			  }
			  if (typeof radius === 'number') {
				radius = {tl: radius, tr: radius, br: radius, bl: radius};
			  } else {
				var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0};
				for (var side in defaultRadius) {
				  radius[side] = radius[side] || defaultRadius[side];
				}
			  }
			  ctx.beginPath();
			  ctx.moveTo(x + radius.tl, y);
			  ctx.lineTo(x + width - radius.tr, y);
			  ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
			  ctx.lineTo(x + width, y + height - radius.br);
			  ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
			  ctx.lineTo(x + radius.bl, y + height);
			  ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
			  ctx.lineTo(x, y + radius.tl);
			  ctx.quadraticCurveTo(x, y, x + radius.tl, y);
			  ctx.closePath();
			  if (fill) {
				ctx.fill();
			  }
			  if (stroke) {
				ctx.stroke();
			  }

			}
			
			class ParticleSystem {
				constructor(width, height) {
					this.NUM_PARTICLES = 100;
					this.PARTICLE_LIFETIME = 40;
					
					this.width = width;
					this.height = height;
					
					this.oldestParticle = 0;
					this.lastTick = 0;
					
					this.particles = new Array(this.NUM_PARTICLES);
					for (let i = 0; i < this.NUM_PARTICLES; i++) {
						this.particles[i] = {};
					}
				}
				
				createParticle(x, y, vx, vy) {
					let p = this.particles[this.oldestParticle];
					p.x = x;
					p.y = y;
					p.vx = vx;
					p.vy = vy;
					p.life = this.PARTICLE_LIFETIME;
					this.oldestParticle++;
					if (this.oldestParticle >= this.NUM_PARTICLES) this.oldestParticle = 0;
				}
				
				tickParticles() {
					if (this.lastTick !== 0) {
						let now = Date.now();
						let deltaTime = (now - this.lastTick) / 16.67; // 60fps is a time factor of 1
						for (let i = 0; i < this.NUM_PARTICLES; i++) {
							let p = this.particles[i];
							if (p.life <= 0) continue;
							let pvx = p.vx * deltaTime;
							let pvy = p.vy * deltaTime;
							p.x += pvx;
							if (p.x > this.width || p.x < 0) {
								// x overflow/underflow
								p.vx = -p.vx;
								p.x += pvx;
							}
							p.y += pvy;
							if (p.y > this.height || p.y < 0) {
								// y overflow/underflow
								p.vy = -p.vy;
								p.y += pvy;
							}
							p.life--;
						}
						this.lastTick = now;
					} else {
						this.lastTick = Date.now();
					}
				}
			}
			
			class Grid {
				constructor(canvas) {
					this.c = canvas;
					this.ctx = canvas.getContext("2d");
					this.width = this.height = 16;
					this.data = Array(this.width * this.height).fill(false);

					// Listen for clicks on the canvas
					
					canvas.addEventListener('click', (e) => {
					  let rect = canvas.getBoundingClientRect(), // abs. size of element
						  scaleX = canvas.width / rect.width,    // relationship bitmap vs. element for X
						  scaleY = canvas.height / rect.height;  // relationship bitmap vs. element for Y
					  
					  this.handleClick((e.clientX - rect.left) * scaleX, (e.clientY - rect.top) * scaleY);
					});
					
					// Construct scale array
					
					let pentatonic = ["A", "B", "C#", "E", "F#"];
					let octave = 3; // base octave
					let octaveoffset = 3;
					this.scale = Array(this.height);
					for (let i = 0; i < this.height; i++) {
						this.scale[i] = pentatonic[i % pentatonic.length] + (octave + Math.floor((i + octaveoffset) / pentatonic.length));
					}
					this.scale = this.scale.reverse(); // higher notes at lower y values, near the top
					
					// Init synth
					
					this.synth = new Tone.PolySynth(16, Tone.Synth, {
						oscillator : {
							type : "sine"
						},
						envelope : {
							attack : 0.005 ,
							decay : 0.1 ,
							sustain : 0.3 ,
							release : 1
						}
					}).toMaster();
					this.synth.volume.value = -10;
					Tone.Transport.loopEnd = '1m'; // loop at one measure
					Tone.Transport.loop = true;
					Tone.Transport.toggle(); // start
					
					// Init particle system
					
					this.particleSystem = new ParticleSystem(this.c.width, this.c.height);
					
					// Kick off drawing loop
					
					let drawContinuous = (function() {
						this.particleSystem.tickParticles();
						this.draw();
						window.requestAnimationFrame(drawContinuous);
					}).bind(this);
					
					drawContinuous();
				}

				getTileValue(x, y) {
					return this.data[x * this.width + y] !== false;
				}

				setTileValue(x, y, bool) {
					if (bool) {
						// Make sure AudioContext has started
						Tone.context.resume();
						// Turning on, schedule note
						this.data[x * this.width + y] = Tone.Transport.schedule((function(time) {
							this.synth.triggerAttackRelease(this.scale[y], Tone.Time('1m') / this.width, time);
							let px = this.c.width / this.width * (x + 0.5);
							let py = this.c.height / this.height * (y + 0.5);
							let velocityscalar = 10;
							let numparticles = 20;
							for (let i = 0; i < 2 * Math.PI; i += 2 * Math.PI / 20) {
								let pvx = Math.cos(i) * velocityscalar;
								let pvy = Math.sin(i) * velocityscalar;
								this.particleSystem.createParticle(px, py, pvx, pvy);
							}
							
						}).bind(this), Tone.Time('1m') / this.width * x);
					
					} else {
						// Turning off, unschedule note
						Tone.Transport.clear(this.data[x * this.width + y]);
						this.data[x * this.width + y] = false;
					}
				}

				toggleTileValue(x, y) {
					this.setTileValue(x, y, !this.getTileValue(x, y));
				}
			  
				draw() {
					this.ctx.beginPath();
					this.ctx.rect(0, 0, this.c.width, this.c.height);
					this.ctx.fillStyle = "black";
					this.ctx.fill();
					
					// Get particle heatmap
					
					let heatmap = this.getParticleHeatMap();
					
					// Draw each tile
					for (let i = 0; i < this.data.length; i++) {
						let dx, dy;
						dx = dy = this.c.width / this.width;
						let gridx = i % this.width;
						let gridy = Math.floor(i / this.width);
						let x = dx * gridx;
						let y = dy * gridy;
						
						// Draw background
						
						let on = this.getTileValue(gridx, gridy);
						
						let playheadx = Math.floor(Tone.Transport.progress * this.width);
						
						let margin;
						if (on) {
							if (gridx === playheadx) {
								this.ctx.fillStyle = "#fff";
								this.ctx.filter = 'blur(2px)';
								margin = 2;
							} else {
								this.ctx.fillStyle = "#dadada";
								this.ctx.filter = 'blur(1px)';
								margin = 3;
							}
						} else {
							const BRIGHTNESS = 0.05; // max particle brightness between 0 and 1
							let fill = colorMixer([255, 255, 255], [51, 51, 51], heatmap[i] / this.particleSystem.PARTICLE_LIFETIME * BRIGHTNESS);
							this.ctx.fillStyle = fill;
							this.ctx.filter = 'none';
							margin = 4;
						}
						roundRect(this.ctx, x+margin, y+margin, dx-2*margin, dy-2*margin, 2, true, false);
					}
				}
				
				getTileCollision(x, y) {
					let dx, dy;
					dx = dy = this.c.width / this.width;
					let xCoord = Math.floor(x / dx);
					let yCoord = Math.floor(y / dy);
					return {x: xCoord, y: yCoord};
				}
			  
				handleClick(x, y) {
					let tile = this.getTileCollision(x, y);
					this.toggleTileValue(tile.x, tile.y);
				}
				
				getParticleHeatMap() {
					let heatmap = Array(this.width * this.height).fill(0);
					let ps = this.particleSystem;
					for (let i = 0; i < ps.NUM_PARTICLES; i++) {
						let p = ps.particles[i];
						let tile = this.getTileCollision(p.x, p.y);
						heatmap[this.width * tile.y + tile.x] = p.life;
					}
					return heatmap;
				}
			}
			
			new Grid(document.querySelector("canvas"));
		})();
	</script>
  </body>
</html>