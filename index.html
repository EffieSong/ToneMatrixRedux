<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
	<meta name="viewport" content="width=530, user-scalable=no">
    <title>ToneMatrix Redux, a no-Flash pentatonic step sequencer</title>
	<style>
		@font-face {
			font-family: 'Montserrat';
			src: url('montserrat-thin-webfont.woff2') format('woff2');
			font-weight: 100;
			font-style: normal;

		}
		html, body {
			background: black;
			margin: 0;
			width: 100%;
			height: 100%;
			font-family: Arial, sans-serif;
		}
		body {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
		}
		body, a {
			color: #777;
		}
		h1 {
			font-family: 'Montserrat', sans-serif;
			font-weight: 100;
			color: #ddd;
		}
	</style>
  </head>
  <body>
	<h1>ToneMatrix Redux</h1>
    <canvas width="500" height="500"></canvas>
	<p>By <a href="https://www.maxlaumeister.com/">Max L</a> - Based on <a href="https://tonematrix.audiotool.com/">ToneMatrix</a> - <a href="https://github.com/MaxLaumeister/ToneMatrixRedux">View on GitHub</a>
	<script src="Tone.js"></script>
	<script>
		(function() {
			// Draw Rounded Rectangle
			// https://stackoverflow.com/a/3368118/2234742
			function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
			  if (typeof stroke === 'undefined') {
				stroke = true;
			  }
			  if (typeof radius === 'undefined') {
				radius = 5;
			  }
			  if (typeof radius === 'number') {
				radius = {tl: radius, tr: radius, br: radius, bl: radius};
			  } else {
				var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0};
				for (var side in defaultRadius) {
				  radius[side] = radius[side] || defaultRadius[side];
				}
			  }
			  ctx.beginPath();
			  ctx.moveTo(x + radius.tl, y);
			  ctx.lineTo(x + width - radius.tr, y);
			  ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
			  ctx.lineTo(x + width, y + height - radius.br);
			  ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
			  ctx.lineTo(x + radius.bl, y + height);
			  ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
			  ctx.lineTo(x, y + radius.tl);
			  ctx.quadraticCurveTo(x, y, x + radius.tl, y);
			  ctx.closePath();
			  if (fill) {
				ctx.fill();
			  }
			  if (stroke) {
				ctx.stroke();
			  }

			}
			
			class Grid {
				constructor(canvas) {
					this.c = canvas;
					this.ctx = canvas.getContext("2d");
					this.width = this.height = 16;
					this.data = Array(this.width * this.height).fill(false);

					// Listen for clicks on the canvas
					
					canvas.addEventListener('click', (e) => {
					  let rect = canvas.getBoundingClientRect(), // abs. size of element
						  scaleX = canvas.width / rect.width,    // relationship bitmap vs. element for X
						  scaleY = canvas.height / rect.height;  // relationship bitmap vs. element for Y
					  
					  this.handleClick((e.clientX - rect.left) * scaleX, (e.clientY - rect.top) * scaleY);
					});
					
					// Construct scale array
					let pentatonic = ["A", "B", "C#", "E", "F#"];
					let octave = 3; // base octave
					let octaveoffset = 3;
					this.scale = Array(this.height);
					for (let i = 0; i < this.height; i++) {
						this.scale[i] = pentatonic[i % pentatonic.length] + (octave + Math.floor((i + octaveoffset) / pentatonic.length));
					}
					this.scale = this.scale.reverse(); // higher notes at lower y values, near the top
					
					// Init synth
					
					this.synth = new Tone.PolySynth(16, Tone.Synth).toMaster();
					this.synth.volume.value = -10;
					Tone.Transport.loopEnd = '1m'; // loop at one measure
					Tone.Transport.loop = true;
					Tone.Transport.toggle(); // start
					
					// Kick off drawing loop
					
					let drawContinuous = (function() {
						this.draw();
						window.requestAnimationFrame(drawContinuous);
					}).bind(this);
					
					drawContinuous();
				}

				getTileValue(x, y) {
					return this.data[x * this.width + y] !== false;
				}

				setTileValue(x, y, bool) {
					if (bool) {
						// Make sure AudioContext has started
						Tone.context.resume();
						// Turning on, schedule note
						this.data[x * this.width + y] = Tone.Transport.schedule((function(time) {
							this.synth.triggerAttackRelease(this.scale[y], Tone.Time('1m') / this.width, time);
						}).bind(this), Tone.Time('1m') / this.width * x);
					
					} else {
						// Turning off, unschedule note
						Tone.Transport.clear(this.data[x * this.width + y]);
						this.data[x * this.width + y] = false;
					}
				}

				toggleTileValue(x, y) {
					this.setTileValue(x, y, !this.getTileValue(x, y));
				}
			  
				draw() {
					this.ctx.beginPath();
					this.ctx.rect(0, 0, this.c.width, this.c.height);
					this.ctx.fillStyle = "black";
					this.ctx.fill();
					
					// Draw each tile
					for (let i = 0; i < this.data.length; i++) {
						let dx, dy;
						dx = dy = this.c.width / this.width;
						let gridx = i % this.width;
						let gridy = Math.floor(i / this.width);
						let x = dx * gridx;
						let y = dy * gridy;
						
						// Draw background
						
						let on = this.getTileValue(gridx, gridy);
						
						this.ctx.beginPath();
						
						let playheadx = Math.floor(Tone.Transport.progress * this.width);
						
						let margin;
						if (on) {
							if (gridx === playheadx) {
								this.ctx.fillStyle = "#fff";
								this.ctx.filter = 'blur(2px)';
								margin = 2;
							} else {
								this.ctx.fillStyle = "#dadada";
								this.ctx.filter = 'blur(1px)';
								margin = 3;
							}
						} else {
							this.ctx.fillStyle =  "#333";
							this.ctx.filter = 'none';
							margin = 4;
						}
						roundRect(this.ctx, x+margin, y+margin, dx-2*margin, dy-2*margin, 2, true, false);
					}
				}
			  
				handleClick(x, y) {
					let dx, dy;
					dx = dy = this.c.width / this.width;
					let xCoord = Math.floor(x / dx);
					let yCoord = Math.floor(y / dy);
					this.toggleTileValue(xCoord, yCoord);
				}
			}
			
			new Grid(document.querySelector("canvas"));
		})();
	</script>
  </body>
</html>